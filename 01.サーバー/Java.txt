1.
コントローラー：リクエストを見て、どのサービスを呼び出すかを判断
・入力チェック(物理チェック)
・権限チェック(論理チェック)
・サービスの呼び出し

サービス：どのマッパー、ロジッククラスを呼び出すかを判断
・実質的な処理
・実質的な処理を行うロジッククラスの呼び出し
・マッパーの呼び出し


2.staticを付ける基準
変数 : 共通属性の場合
メソッド : インスタンス変数/インスタンスメソッドを使わないメソッド。
staticメソッドはインスタンスメソッドを呼び出せない。


3.
Q. staticメソッドはstaticメソッドを呼び出せるか？
A. はい。
Q. staticメソッドはインスタンス変数を使用可能か？
A. いいえ。
Q. staticメソッドはインスタンスメソッドを呼び出せるか？
A. いいえ。
Q. なぜstaticメソッドはインスタンスメンバーを使えないのか？
A. オブジェクトが存在するかどうか分からないから。


4.カプセル化の基本 (望ましいコーディング方法)
・変数 : privateで定義。
・メソッド : publicで定義。
・値の操作は必ずメソッドを通じて行うようにする。（get,set）


5.instanceof 演算子
型変換可能かを確認する演算子。
可能ならtrueを返す。


6.複数のオブジェクトを配列で管理
------------------------------------
// 親クラス　　　子クラス
Product p1 = new TV();
Product p2 = new Computer();
Product p3 = new Audio();
------------------------------------
　　　　　　　↓
------------------------------------
Product p[] = new Product[3];
p[0] = new TV();
p[1] = new Computer();
p[2] = new Audio();
------------------------------------


7.拡張for文
int[] arr = {1, 2, 3, 4};
for (int i : arr) {
  System.out.println(i);
}
// 一言で、arrの奴らを無くなるまでiに入れる。


8.
全ての例外の最上位クラス : Exception
なので、例外の種類が予想できない場合はExceptionを使ったらよい。
try {
  // 実行するコード
} catch (Exception e) {
  e.printStackTrace(); // どんな例外もキャッチできる
}


9.
メソッド内名に「throws」をつけたら、呼び出したメソッド側で「try-catch」が強制される。
throw : 特定の例外を意図的に発生させるときに使用
throws : 自分を呼び出した上位メソッドにエラーを投げる


10.Collectionの主要インターフェース
・List : 順序あり、重複あり
・Set : 順序なし、重複なし
・Map : 順序あり、キーは重複なし、値は重複あり


11.Listはインターフェースで、主な実装クラスは以下の通り
・List<Dto> list1 = new ArrayList<Dto>();
・List<Dto> list2 = new LinkedList<Dto>();
・List<Dto> list3 = new Vector<Dto>();
・List<Dto> list4 = new List<Dto>(); // エラー


12.ArrayListの追加はaddだ
InfoDTO infoDTO1 = new InfoDTO();
List<InfoDTO> dtoList = new ArrayList<>;
dtoList.set(0,infoDTO1) // Error
dtoList.add(infoDTO1)   // OK


13.
Junitで意図的に例外を発生させる方法
result = new IOException(anyString)